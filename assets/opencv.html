<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Leaf Analyzer</title>
    <style>
      body, html { margin:0; padding:0; overflow:hidden; }
      #canvas { display:none; }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script async src="opencv.js" onload="onOpenCvReady();"></script>
    <script>
      let debug = false;
      const params = new URLSearchParams(window.location.search);
      if (params.get('debug') === 'true') {
        debug = true;
      }
      const canvasEl = document.getElementById('canvas');
      canvasEl.style.display = debug ? 'block' : 'none';

      function onOpenCvReady() {
        cv['onRuntimeInitialized'] = () => {
          window.ReactNativeWebView.postMessage(
            JSON.stringify({ type: 'ready' })
          );
        };
      }

      window.processImage = function(imageData, width, height, pxPerCell) {
        if (typeof width !== 'number' || typeof height !== 'number' || typeof pxPerCell !== 'number' ||
            width <= 0 || height <= 0 || pxPerCell <= 0) {
          window.ReactNativeWebView.postMessage(
            JSON.stringify({ type: 'error', message: 'Invalid parameters' })
          );
          return;
        }
        try {
          let img = new Image();
          img.onload = () => {
            let canvas = document.getElementById('canvas');
            canvas.width = width; canvas.height = height;
            let ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            let src = cv.imread(canvas);

            let gray = new cv.Mat();
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            cv.GaussianBlur(gray, gray, new cv.Size(5,5), 0);
            let edges = new cv.Mat();
            cv.Canny(gray, edges, 50, 150);

            let contours = new cv.MatVector();
            let hierarchy = new cv.Mat();
            cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
            let contourCount = contours.size();
            let markerFound = false;
            let calculatedPxPerCell = pxPerCell;

            for (let i = 0; i < contours.size(); ++i) {
              const cnt = contours.get(i);
              if (cnt.data32S.length >= 8) {
                let minX = Number.MAX_VALUE, minY = Number.MAX_VALUE;
                let maxX = 0, maxY = 0;
                for (let j = 0; j < cnt.data32S.length; j += 2) {
                  const x = cnt.data32S[j];
                  const y = cnt.data32S[j + 1];
                  if (x < minX) minX = x;
                  if (y < minY) minY = y;
                  if (x > maxX) maxX = x;
                  if (y > maxY) maxY = y;
                }
                const widthR = maxX - minX;
                const heightR = maxY - minY;
                const aspect = widthR / heightR;
                const areaR = widthR * heightR;
                if (
                  aspect > 0.8 &&
                  aspect < 1.2 &&
                  areaR > pxPerCell * pxPerCell * 0.5 &&
                  areaR < pxPerCell * pxPerCell * 2
                ) {
                  markerFound = true;
                  calculatedPxPerCell = Math.sqrt(areaR);
                  break;
                }
              }
            }

            pxPerCell = calculatedPxPerCell;

            if (debug) {
              ctx.lineWidth = 2;
              ctx.strokeStyle = "red";

              ctx.beginPath();
              for (let i = 0; i < contours.size(); ++i) {
                const cnt = contours.get(i);
                for (let j = 0; j < cnt.data32S.length; j += 2) {
                  const x = cnt.data32S[j];
                  const y = cnt.data32S[j + 1];
                  if (j === 0) ctx.moveTo(x, y);
                  else ctx.lineTo(x, y);
                }
                ctx.closePath();
              }
              ctx.stroke();
            }
            let points = [];
            let maxArea = 0;
            for (let i = 0; i < contours.size(); ++i) {
              const cnt = contours.get(i);
              const area = cv.contourArea(cnt);
              if (area > maxArea) {
                maxArea = area;
                points = [];
                for (let j = 0; j < cnt.data32S.length; j += 2) {
                  points.push({ x: cnt.data32S[j], y: cnt.data32S[j + 1] });
                }
              }
            }

            let result = maxArea;

            src.delete(); gray.delete(); edges.delete();
            contours.delete(); hierarchy.delete();
  window.ReactNativeWebView.postMessage(JSON.stringify({
    type: 'result',
    area: result,
    pxPerCell: pxPerCell,
    contour: points,
    contourCount: contourCount,
    markerFound: markerFound
  }));
          };
          img.onerror = () => {
            window.ReactNativeWebView.postMessage(
              JSON.stringify({
                type: 'error',
                message: 'Image load failed'
              })
            );
          };
          img.src = 'data:image/png;base64,' + imageData;
        } catch (e) {
          window.ReactNativeWebView.postMessage(JSON.stringify({
            type: 'error',
            message: e.toString()
          }));
        }
      };
    </script>
  </body>
</html>
